const char* Particles_comp =
"/*-- Compute shader for a single particle in a SINGLE particle system --*/\n"
"#version 430\n"
"\n"
"layout(local_size_x = 64) in;\n"
"\n"
"struct Particle {\n"
"	vec3 Position;\n"
"	vec3 Velocity;\n"
"	vec3 acceleration;\n"
"	vec4 color;\n"
"	float lifeTime;\n"
"    uint prevSubChunkIndex;\n"
"};\n"
"\n"
"uniform bool reset;\n"
"\n"
"uniform vec3 emitterPosition;\n"
"uniform float defaultLifeTime;\n"
"uniform vec4 startColor;\n"
"uniform vec4 endColor;\n"
"uniform vec3 initialVelocity;\n"
"uniform vec3 defaultAcceleration; // using initialVelocity along with defaultAcceleration, a variety of patterns and effects can be created\n"
"uniform float defaultLifeTimeRandomness; // 0 -> no change in lifeTime, 1 -> lifeTime widely different from defaultLifeTime\n"
"uniform float initialVelocityRandomness; // 0 -> no change in Velocity, 1 -> Velocity widely different from initialVelocity\n"
"uniform float accelerationRandomnessPerFrame; // 0 -> sticks to defaultAcceleration, 1 -> widely different from defaultAcceleration --> in between [0 - 1]: adds some jerk/jitty to particles\n"
"\n"
"uniform int seed;\n"
"\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"uniform ivec3 chunkNum;\n"
"uniform float voxelSize;\n"
"uniform float chunkSize;\n"
"uniform ivec3 chunkSubDivision;\n"
"\n"
"uniform float dt;\n"
"\n"
"layout(std430, binding = 0) buffer Chunks {\n"
"    uint chunks[];\n"
"};\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[];\n"
"};\n"
"\n"
"layout(std430, binding = 2) buffer ChunkEmpty {\n"
"    uint chunkEmpty[]; // 0 = not empty, 1 = empty, 2 = temporary not empty\n"
"};\n"
"\n"
"layout(std430, binding = 3) buffer Particles {\n"
"    Particle particles[];\n"
"};\n"
"\n"
"int unpackSigned10(uint v) {\n"
"    return (v & 0x200) != 0 ? int(v | 0xFFFFFC00) : int(v & 0x3FF);\n"
"}\n"
"\n"
"vec3 getChunk(uint idx) {\n"
"    uint packedChunk = chunks[idx];\n"
"    uint xBits = (packedChunk >> 20) & 0x3FF;\n"
"    uint yBits = (packedChunk >> 10) & 0x3FF;\n"
"    uint zBits =  packedChunk        & 0x3FF;\n"
"    return vec3(\n"
"        unpackSigned10(xBits),\n"
"        unpackSigned10(yBits),\n"
"        unpackSigned10(zBits)\n"
"    ) * chunkSize;\n"
"}\n"
"\n"
"float hash13(vec3 p) {\n"
"    p = fract(p * 0.1031);\n"
"    p += dot(p, p.yzx + 33.33);\n"
"    return fract((p.x + p.y) * p.z);\n"
"}\n"
"\n"
"vec3 randomVec3(uint seed, uint id) {\n"
"    return vec3(\n"
"        hash13(vec3(float(seed), float(id), 1.0)),\n"
"        hash13(vec3(float(seed), float(id), 2.0)),\n"
"        hash13(vec3(float(seed), float(id), 3.0))\n"
"    );\n"
"}\n"
"\n"
"struct Indexes{\n"
"    int chunkIdx;\n"
"    int voxelIdx;\n"
"};\n"
"\n"
"Indexes getIndex(vec3 worldPos) {\n"
"    ivec3 voxelGlobalIndex = ivec3(floor(worldPos / voxelSize));\n"
"    ivec3 chunkIndex = voxelGlobalIndex / VoxelCountPerChunk;\n"
"    ivec3 voxelIndex = voxelGlobalIndex % VoxelCountPerChunk;\n"
"\n"
"    // Out-of-bounds safety\n"
"    if (any(lessThan(chunkIndex, ivec3(0))) || any(greaterThanEqual(chunkIndex, chunkNum)))\n"
"        return Indexes(-1, -1);\n"
"\n"
"    int chunkFlatIndex = chunkIndex.x * (chunkNum.y * chunkNum.z) +\n"
"                     chunkIndex.y * chunkNum.z +\n"
"                     chunkIndex.z;\n"
"    int voxelFlatIndex = voxelIndex.z * (VoxelCountPerChunk.y * VoxelCountPerChunk.x) +\n"
"                         voxelIndex.y * VoxelCountPerChunk.x +\n"
"                         voxelIndex.x;\n"
"\n"
"    return Indexes(chunkFlatIndex, voxelFlatIndex + chunkFlatIndex * (VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z));\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"int getVoxelValue(vec3 worldPos) {\n"
"    int idx = getIndex(worldPos).voxelIdx;\n"
"    return (idx != -1 && voxels[idx] != 0u) ? 1 : 0;\n"
"}\n"
"\n"
"vec3 computeNormal(vec3 worldPos) {\n"
"    float delta = voxelSize; // sample step, typically the size of one voxel\n"
"\n"
"    // Offsets in each direction\n"
"    float dx = float(getVoxelValue(worldPos + vec3(delta, 0, 0))) - float(getVoxelValue(worldPos - vec3(delta, 0, 0)));\n"
"    float dy = float(getVoxelValue(worldPos + vec3(0, delta, 0))) - float(getVoxelValue(worldPos - vec3(0, delta, 0)));\n"
"    float dz = float(getVoxelValue(worldPos + vec3(0, 0, delta))) - float(getVoxelValue(worldPos - vec3(0, 0, delta)));\n"
"\n"
"    vec3 normal = normalize(vec3(dx, dy, dz));\n"
"    return normal;\n"
"}\n"
"\n"
"void resetPrevSubchunk(uint prevSubChunkIndex) {\n"
"    if (chunkEmpty[prevSubChunkIndex] == 2) chunkEmpty[prevSubChunkIndex] = 1; // if temporary not empty: set to empty\n"
"}\n"
"\n"
"void SetSubChunkNotEmpty(inout Particle p, uint chunkIdx) {\n"
"    vec3 chunkWorldOrigin = getChunk(chunkIdx);\n"
"    vec3 localOffset = (p.Position - chunkWorldOrigin) / voxelSize;\n"
"\n"
"    ivec3 localVoxelCoord = ivec3(floor(localOffset)); // i, j, k inside chunk\n"
"\n"
"    vec3 subDivisionSize = chunkSize / chunkSubDivision;\n"
"    \n"
"    ivec3 subIndex = ivec3(floor(vec3(localVoxelCoord * voxelSize) / subDivisionSize));\n"
"    \n"
"    int index = subIndex.x\n"
"              + subIndex.y * chunkSubDivision.x \n"
"              + subIndex.z * chunkSubDivision.x * chunkSubDivision.y;\n"
"\n"
"    p.prevSubChunkIndex = index + chunkIdx * chunkSubDivision.x * chunkSubDivision.y * chunkSubDivision.z;\n"
"    if (chunkEmpty[p.prevSubChunkIndex] == 1) chunkEmpty[p.prevSubChunkIndex] = 2; // if empty: set to temporary not empty\n"
"}\n"
"\n"
"void resetParticle(uint id) {\n"
"	Particle p;\n"
"\n"
"	p.lifeTime = defaultLifeTime + hash13(vec3(float(seed), float(id), 1.0)) * defaultLifeTimeRandomness * defaultLifeTime;\n"
"\n"
"    // Start position at emitter\n"
"    p.Position = emitterPosition;\n"
"\n"
"    // Randomized initial velocity\n"
"    vec3 randomVel = randomVec3(seed, id);\n"
"    p.Velocity = initialVelocity + (randomVel - 0.5) * 2.0 * initialVelocityRandomness * length(initialVelocity);\n"
"\n"
"    // Randomized acceleration (can change every frame)\n"
"    vec3 randomAcc = randomVec3(seed, id);\n"
"    p.acceleration = defaultAcceleration + (randomAcc - 0.5) * 2.0 * accelerationRandomnessPerFrame * length(defaultAcceleration);\n"
"\n"
"    // Color can stay constant or be randomized similarly if desired\n"
"    p.color = startColor;\n"
"\n"
"    particles[id] = p;\n"
"}\n"
"\n"
"void updateParticle(uint id) {\n"
"    // Erase old voxel color at previous position\n"
"    Indexes indexes = getIndex(particles[id].Position);\n"
"    voxels[indexes.voxelIdx] = packRGBA(vec4(0.0));\n"
"    resetPrevSubchunk(particles[id].prevSubChunkIndex);\n"
"\n"
"    // Reset particle if needed\n"
"    if (reset || particles[id].lifeTime <= 0.0) {\n"
"        resetParticle(id);\n"
"    }\n"
"\n"
"    Particle p = particles[id];\n"
"\n"
"    // Randomized acceleration (adds jitter)\n"
"    vec3 randomAcc = randomVec3(seed + 535u, id);\n"
"    p.acceleration = defaultAcceleration + (randomAcc - 0.5) * 2.0 * accelerationRandomnessPerFrame * length(defaultAcceleration);\n"
"\n"
"    // Physics update\n"
"    vec3 prevPos = p.Position;\n"
"    p.Velocity += p.acceleration * dt;\n"
"    p.Position += p.Velocity * dt;\n"
"\n"
"    // Lifetime countdown\n"
"    p.lifeTime -= dt;\n"
"\n"
"    float lifeRatio = clamp(p.lifeTime / defaultLifeTime, 0.0, 1.0);\n"
"    p.color = mix(endColor, startColor, lifeRatio); // start -> end over time\n"
"\n"
"    // Set voxel color at new position\n"
"    indexes = getIndex(p.Position);\n"
"    if (indexes.voxelIdx != -1) {\n"
"        if (voxels[indexes.voxelIdx] == 0u) {\n"
"            voxels[indexes.voxelIdx] = packRGBA(p.color);\n"
"            SetSubChunkNotEmpty(p, indexes.chunkIdx);\n"
"        }\n"
"        else {\n"
"            vec3 normal = computeNormal(p.Position);\n"
"            if (length(normal) < 0.001) normal = vec3(0, 1, 0); // fallback\n"
"\n"
"            // Step back a bit to avoid getting stuck inside the surface\n"
"            p.Position = prevPos;\n"
"\n"
"            // Reflect the velocity vector using the estimated normal\n"
"            p.Velocity = reflect(p.Velocity, normal) * 0.6; // bounce + energy loss\n"
"        }\n"
"    } else {\n"
"        p.lifeTime = -1.0;\n"
"    }\n"
"\n"
"    // Save updated particle\n"
"    particles[id] = p;\n"
"}\n"
"\n"
"void main() {\n"
"	uint id = gl_GlobalInvocationID.x;\n"
"\n"
"    updateParticle(id);\n"
"}\n"
;
