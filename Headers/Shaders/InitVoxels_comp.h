const char* InitVoxels_comp =
"#version 430\n"
"\n"
"layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;\n"
"\n"
"uniform uint chunkIdx; \n"
"uniform float chunkSize;\n"
"uniform float frequency;\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"uniform ivec3 chunkNum;\n"
"\n"
"uniform uint uSeed;\n"
"\n"
"layout(std430, binding = 0) buffer Chunks {\n"
"    uint chunks[];\n"
"};\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[];\n"
"};\n"
"\n"
"layout(std430, binding = 2) buffer ChunkEmpty {\n"
"    uint chunkEmpty[];\n"
"};\n"
"\n"
"int unpackSigned10(uint v) {\n"
"    return (v & 0x200) != 0 ? int(v | 0xFFFFFC00) : int(v & 0x3FF);\n"
"}\n"
"\n"
"vec3 getChunk(uint idx) {\n"
"    uint packedChunk = chunks[idx];\n"
"    uint xBits = (packedChunk >> 20) & 0x3FF;\n"
"    uint yBits = (packedChunk >> 10) & 0x3FF;\n"
"    uint zBits =  packedChunk        & 0x3FF;\n"
"    return vec3(\n"
"        unpackSigned10(xBits),\n"
"        unpackSigned10(yBits),\n"
"        unpackSigned10(zBits)\n"
"    ) * chunkSize;\n"
"}\n"
"\n"
"int getIndex(ivec3 pos) {\n"
"    return pos.x + VoxelCountPerChunk.x * (pos.y + VoxelCountPerChunk.y * pos.z);\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"uint hash(uint x, uint seed) {\n"
"    const uint m = 0x5bd1e995U;\n"
"    uint hash = seed;\n"
"    // process input\n"
"    uint k = x;\n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"    // some final mixing\n"
"    hash ^= hash >> 13;\n"
"    hash *= m;\n"
"    hash ^= hash >> 15;\n"
"    return hash;\n"
"}\n"
"\n"
"uint hash(uvec3 x, uint seed){\n"
"    const uint m = 0x5bd1e995U;\n"
"    uint hash = seed;\n"
"    // process first vector element\n"
"    uint k = x.x; \n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"    // process second vector element\n"
"    k = x.y; \n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"    // process third vector element\n"
"    k = x.z; \n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"	// some final mixing\n"
"    hash ^= hash >> 13;\n"
"    hash *= m;\n"
"    hash ^= hash >> 15;\n"
"    return hash;\n"
"}\n"
"\n"
"vec3 gradientDirection(uint hash) {\n"
"    switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction\n"
"    case 0:\n"
"        return vec3(1, 1, 0);\n"
"    case 1:\n"
"        return vec3(-1, 1, 0);\n"
"    case 2:\n"
"        return vec3(1, -1, 0);\n"
"    case 3:\n"
"        return vec3(-1, -1, 0);\n"
"    case 4:\n"
"        return vec3(1, 0, 1);\n"
"    case 5:\n"
"        return vec3(-1, 0, 1);\n"
"    case 6:\n"
"        return vec3(1, 0, -1);\n"
"    case 7:\n"
"        return vec3(-1, 0, -1);\n"
"    case 8:\n"
"        return vec3(0, 1, 1);\n"
"    case 9:\n"
"        return vec3(0, -1, 1);\n"
"    case 10:\n"
"        return vec3(0, 1, -1);\n"
"    case 11:\n"
"        return vec3(0, -1, -1);\n"
"    case 12:\n"
"        return vec3(1, 1, 0);\n"
"    case 13:\n"
"        return vec3(-1, 1, 0);\n"
"    case 14:\n"
"        return vec3(0, -1, 1);\n"
"    case 15:\n"
"        return vec3(0, -1, -1);\n"
"    }\n"
"}\n"
"\n"
"float interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n"
"    return mix(\n"
"        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n"
"        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n"
"        t.z\n"
"    );\n"
"}\n"
"\n"
"vec3 fade(vec3 t) {\n"
"    // 6t^5 - 15t^4 + 10t^3\n"
"	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n"
"}\n"
"\n"
"float perlinNoise(vec3 position, uint seed) {\n"
"    vec3 floorPosition = floor(position);\n"
"    vec3 fractPosition = position - floorPosition;\n"
"    uvec3 cellCoordinates = uvec3(floorPosition);\n"
"    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n"
"    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n"
"    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n"
"    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n"
"    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n"
"    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n"
"    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n"
"    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n"
"    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n"
"}\n"
"\n"
"float perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n"
"    float value = 0.0;\n"
"    float amplitude = 1.0;\n"
"    float currentFrequency = float(frequency);\n"
"    uint currentSeed = seed;\n"
"    for (int i = 0; i < octaveCount; i++) {\n"
"        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n"
"        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n"
"        amplitude *= persistence;\n"
"        currentFrequency *= lacunarity;\n"
"    }\n"
"    return value;\n"
"}\n"
"\n"
"vec4 getTerrainColor(vec3 worldPos, vec3 worldSize, ivec3 localPos, vec3 chunkOrigin, float perlinValue, uint seed) {\n"
"    float heightPercent = worldPos.y / worldSize.y;\n"
"\n"
"    bool isStone   = heightPercent > 0.05;\n"
"    bool isBedrock = heightPercent <= 0.05;\n"
"\n"
"    uint h = hash(localPos + ivec3(chunkOrigin), seed);\n"
"    float r = float(h & 0xFFu) / 255.0;\n"
"\n"
"    vec4 baseStone    = vec4(0.4 + 0.1 * r, 0.4 + 0.1 * r, 0.4 + 0.1 * r, 1.0);\n"
"    vec4 darkStone    = vec4(0.1 + 0.05 * r, 0.1 + 0.05 * r, 0.1 + 0.05 * r, 1.0);\n"
"\n"
"    float stoneBlend  = smoothstep(0.05, 0.6, heightPercent); // shallow = 1.0, deep = 0.0\n"
"    vec4 stoneColor   = mix(darkStone, baseStone, stoneBlend);\n"
"\n"
"    vec4 crystalColor = vec4(0.8, 0.9, 1.0, 1.0);\n"
"    vec4 bedrockColor = vec4(0.05, 0.05, 0.05, 1.0);\n"
"\n"
"    bool rareCrystal = (h % 101u) == 0;\n"
"    bool Hole        = (h % 6u) == 0;\n"
"\n"
"    bool solid = perlinValue > 0.45 && !Hole;\n"
"\n"
"    vec4 voxel = vec4(0.0);\n"
"    if (isStone && solid) {\n"
"        voxel = rareCrystal ? crystalColor : stoneColor;\n"
"    } else if (isBedrock) {\n"
"        voxel = bedrockColor;\n"
"    }\n"
"\n"
"    return voxel;\n"
"}\n"
"\n"
"vec4 getSurfaceFeatures(vec3 worldPos, vec3 worldSize, vec3 worldGradient, ivec3 localPos, vec3 chunkOrigin, float perlinValue, uint seed) {\n"
"    // Calculate a 2D height value using Perlin noise (XZ-plane)\n"
"    float hillFrequency = 0.05; // Adjust to control hill width\n"
"    float terrainBase = worldSize.y - chunkSize;\n"
"    float hillHeight = chunkSize * 0.45;    // Max height of hills in world units\n"
"\n"
"    vec2 hillPos = worldPos.xz * hillFrequency;\n"
"    float hillNoise = perlinNoise(vec3(hillPos.x, 0.0, hillPos.y) / frequency, seed);\n"
"    hillNoise = (hillNoise + 1.0) * 0.5; // Normalize to [0, 1]\n"
"\n"
"    float terrainHeight = hillNoise * hillHeight + terrainBase; // base elevation + hills\n"
"\n"
"    uint h = hash(localPos + ivec3(chunkOrigin), seed);\n"
"    float r = float(h & 0xFFu) / 255.0;\n"
"\n"
"    // Check if this voxel is at the surface\n"
"    if ((worldPos.y - terrainHeight) < 1.5) {\n"
"        float heightPercent = clamp((worldPos.y - terrainBase) / hillHeight, 0.0, 1.0);\n"
"\n"
"        float grassBlend = smoothstep(0.45, 1.0, heightPercent);\n"
"        float dirtBlend  = smoothstep(0.005, 0.45, heightPercent) * (1.0 - grassBlend);\n"
"        float stoneBlend =  1.0 - grassBlend - dirtBlend;\n"
"        \n"
"        vec4 grassColor  = vec4(0.2 + 0.2 * r, 0.6 + 0.2 * r, 0.2 + 0.1 * r, 1.0);\n"
"        vec4 dirtColor   = vec4(0.35 + 0.1 * r, 0.25 + 0.1 * r, 0.15 + 0.05 * r, 1.0);\n"
"        vec4 stoneColor  = vec4(0.4 + 0.1 * r, 0.4 + 0.1 * r, 0.4 + 0.1 * r, 1.0);\n"
"        vec4 crystalColor= vec4(0.8, 0.9, 1.0, 1.0);\n"
"        \n"
"        vec4 finalColor = grassColor * grassBlend + dirtColor * dirtBlend + stoneColor * stoneBlend;\n"
"\n"
"        bool rareCrystal = (h % 101u) == 0;\n"
"        bool rareGray    = (h % 67u) == 0;\n"
"\n"
"        float caveNoise = perlinNoise(worldGradient / frequency, seed);\n"
"        caveNoise = (caveNoise + 1.0) * 0.5;\n"
"        \n"
"        bool solid = caveNoise > 0.4;\n"
"        //bool Hole = ((h % 6u) == 0 || (!solid));\n"
"        bool Hole = (!solid);\n"
"        \n"
"        if (rareCrystal && stoneBlend > 0.5) finalColor = crystalColor;\n"
"        else if (rareGray && dirtBlend > 0.5) finalColor = vec4(0.3, 0.3, 0.3, 1.0);\n"
"        \n"
"        return Hole ? vec4(0.0) : finalColor;\n"
"    }\n"
"\n"
"    return vec4(0.0);\n"
"}\n"
"\n"
"void main() {\n"
"    ivec3 localPos = ivec3(gl_GlobalInvocationID); // (0 to VoxelCountPerChunk - 1)\n"
"\n"
"    // Out of bounds check\n"
"    if (any(greaterThanEqual(localPos, VoxelCountPerChunk)) || any(greaterThan(vec3(0.0), localPos))) return;\n"
"\n"
"    vec3 voxelSpacing = chunkSize / vec3(VoxelCountPerChunk);\n"
"    vec3 chunkOrigin = vec3(getChunk(chunkIdx));\n"
"    vec3 worldPos = chunkOrigin + vec3(localPos) * voxelSpacing;\n"
"\n"
"    vec3 worldSize = chunkNum * chunkSize;\n"
"\n"
"    // Simple gradient based on normalized coordinates\n"
"    vec3 chunkGradient = vec3(localPos) / vec3(VoxelCountPerChunk - 1);\n"
"    vec3 worldGradient = worldPos / (vec3(chunkSize.x) - voxelSpacing);\n"
"\n"
"    const uint seed = uSeed;\n"
"\n"
"    float value = perlinNoise(worldGradient / frequency, seed);\n"
"    value = (value + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n"
"\n"
"    vec4 voxel = (chunkOrigin.y == worldSize.y - chunkSize) ? getSurfaceFeatures(worldPos, worldSize, worldGradient, localPos, chunkOrigin, value, seed) : getTerrainColor(worldPos, worldSize, localPos, chunkOrigin, value, seed);\n"
"\n"
"    uint index = getIndex(localPos) + (VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z * chunkIdx);\n"
"    voxels[index] = packRGBA(voxel);\n"
"}\n"
;
