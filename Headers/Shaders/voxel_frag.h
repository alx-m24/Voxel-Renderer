inline static constexpr const char* voxel_frag =
"#version 430 core\n"
"\n"
"layout (location = 0) out vec4 fragColor;\n"
"layout (location = 1) out vec4 BrightColor;\n"
"\n"
"uniform vec2 uResolution;\n"
"uniform vec3 uOrigin;\n"
"uniform vec3 uRight;\n"
"uniform vec3 uUp;\n"
"uniform float uRayOffset;\n"
"uniform float far;\n"
"uniform mat4 uViewMatrix;\n"
"uniform mat4 uProjectionMatrix;\n"
"\n"
"uniform float chunkSize;\n"
"uniform uint chunkNum;\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"\n"
"uniform ivec3 chunkSubDivision;\n"
"\n"
"uniform int ViewingMode;\n"
"\n"
"// Shadows\n"
"uniform bool u_EnableShadows;\n"
"uniform float u_ShadowDist;\n"
"uniform float u_ShadowFar;\n"
"\n"
"// Reflections\n"
"uniform bool u_EnableReflections;\n"
"uniform float u_ReflectionFar;\n"
"uniform int u_MaxReflectionNum;\n"
"\n"
"// Transparency\n"
"uniform bool u_EnableTransparency;\n"
"uniform int u_MaxTransparencyNum;\n"
"\n"
"// Lighting\n"
"uniform int u_MultipleLights;\n"
"\n"
"struct DirLight {\n"
"    vec3 direction;\n"
"\n"
"    vec3 ambient;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"\n"
"    vec3 color;\n"
"};\n"
"\n"
"uniform DirLight dirlight;\n"
"\n"
"struct PointLight{\n"
"    vec3 position;\n"
"    vec3 color;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"};\n"
"\n"
"#define MAX_POINTLIGHTS 1\n"
"\n"
"uniform int pointLightNum;\n"
"uniform PointLight pointlights[MAX_POINTLIGHTS];\n"
"\n"
"const float error_padding = 0.0001;\n"
"const uint voxelOffsetByChunk = VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z;\n"
"const vec3 voxelSize = chunkSize / vec3(VoxelCountPerChunk);\n"
"const vec3 subDivisionSize = chunkSize / vec3(chunkSubDivision);\n"
"const uint subChunkStride = chunkSubDivision.x * chunkSubDivision.y * chunkSubDivision.z;\n"
"\n"
"layout(std430, binding = 0) buffer Chunks {\n"
"    uint chunks[]; // chunk positions\n"
"};\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[]; // a = 0.0 -> empty, 0.0 < a <= 0.5 -> (semi)-transparent, 0.5 < a <= 0.8 -> reflective, a = 0.9 -> emissive, a = 1.0 -> solid\n"
"};\n"
"\n"
"layout(std430, binding = 2) buffer ChunkEmpty {\n"
"    uint chunkEmpty[];  // 0 = not empty, 1 = empty, 2 = temporary not empty\n"
"};\n"
"\n"
"struct HitPoint {\n"
"    vec4 color;\n"
"    ivec3 normal;\n"
"    vec3 position;\n"
"};\n"
"\n"
"int getIndex(ivec3 pos) {\n"
"    return pos.x + VoxelCountPerChunk.x * (pos.y + VoxelCountPerChunk.y * pos.z);\n"
"}\n"
"\n"
"void getRay(out vec3 rayOrigin, out vec3 rayDirection) {\n"
"    vec2 uv = gl_FragCoord.xy / uResolution; \n"
"    vec2 ndc = 2.0 * uv - 1.0;  // Convert to range [-1, 1]\n"
"    \n"
"    vec4 clipSpacePos = vec4(ndc, -1.0, 1.0); // Perspective projection NDC space\n"
"    \n"
"    vec4 viewSpacePos = inverse(uProjectionMatrix) * clipSpacePos; // Undo projection\n"
"    viewSpacePos /= viewSpacePos.w; // Convert from homogeneous coordinates\n"
"    \n"
"    rayDirection = normalize((inverse(uViewMatrix) * vec4(viewSpacePos.xyz, 0.0)).xyz); // Transform to world space\n"
"\n"
"    rayOrigin = uOrigin + uRayOffset * (uRight * ndc.x + uUp * ndc.y);\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"int unpackSigned10(uint v) {\n"
"    return (v & 0x200) != 0 ? int(v | 0xFFFFFC00) : int(v & 0x3FF);\n"
"}\n"
"\n"
"vec3 getChunk(uint idx) {\n"
"    uint packedChunk = chunks[idx];\n"
"    uint xBits = (packedChunk >> 20) & 0x3FF;\n"
"    uint yBits = (packedChunk >> 10) & 0x3FF;\n"
"    uint zBits =  packedChunk        & 0x3FF;\n"
"    return vec3(\n"
"        unpackSigned10(xBits),\n"
"        unpackSigned10(yBits),\n"
"        unpackSigned10(zBits)\n"
"    ) * chunkSize;\n"
"}\n"
"\n"
"vec4 getVoxel(uint idx) {\n"
"    uint rgba = voxels[idx];\n"
"    float r = float((rgba >> 24) & 0xFFu) / 255.0;\n"
"    float g = float((rgba >> 16) & 0xFFu) / 255.0;\n"
"    float b = float((rgba >> 8)  & 0xFFu) / 255.0;\n"
"    float a = float(rgba & 0xFFu) / 255.0;\n"
"    return vec4(r, g, b, a);\n"
"}\n"
"\n"
"uint hash(uint x, uint seed) {\n"
"    const uint m = 0x5bd1e995U;\n"
"    uint hash = seed;\n"
"    // process input\n"
"    uint k = x;\n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"    // some final mixing\n"
"    hash ^= hash >> 13;\n"
"    hash *= m;\n"
"    hash ^= hash >> 15;\n"
"    return hash;\n"
"}\n"
"\n"
"uint hash(uvec3 x, uint seed){\n"
"    const uint m = 0x5bd1e995U;\n"
"    uint hash = seed;\n"
"    // process first vector element\n"
"    uint k = x.x; \n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"    // process second vector element\n"
"    k = x.y; \n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"    // process third vector element\n"
"    k = x.z; \n"
"    k *= m;\n"
"    k ^= k >> 24;\n"
"    k *= m;\n"
"    hash *= m;\n"
"    hash ^= k;\n"
"	// some final mixing\n"
"    hash ^= hash >> 13;\n"
"    hash *= m;\n"
"    hash ^= hash >> 15;\n"
"    return hash;\n"
"}\n"
"\n"
"vec3 sky(vec3 direction) {\n"
"    vec3 lightDir = normalize(dirlight.direction);\n"
"    vec3 lightColor = dirlight.color;\n"
"\n"
"    float sunHeight = clamp(dot(vec3(0.0, 1.0, 0.0), -lightDir), -1.0, 1.0);\n"
"\n"
"    // Time of day (0 = night, 1 = day)\n"
"    float dayAmount = smoothstep(-0.1, 0.1, sunHeight);\n"
"    float sunsetAmount = smoothstep(0.0, 0.2, abs(sunHeight));\n"
"\n"
"    // Color palettes\n"
"    vec3 dayZenith = vec3(0.2, 0.5, 0.85);\n"
"    vec3 dayHorizon = vec3(0.8, 0.7, 0.5);\n"
"\n"
"    vec3 nightZenith = vec3(0.01, 0.02, 0.05);\n"
"    vec3 nightHorizon = vec3(0.05, 0.03, 0.07);\n"
"\n"
"    vec3 sunsetTint = vec3(1.0, 0.4, 0.2); // reddish-orange\n"
"\n"
"    // Interpolate day/night based on upness\n"
"    float t = clamp(0.5 * (direction.y + 1.0), 0.0, 1.0);\n"
"    vec3 zenithColor = mix(nightZenith, dayZenith, dayAmount);\n"
"    vec3 horizonColor = mix(nightHorizon, dayHorizon, dayAmount);\n"
"\n"
"    // Final base sky color\n"
"    vec3 baseSky = mix(horizonColor, zenithColor, t);\n"
"\n"
"    // Sun disk\n"
"    float sunDot = max(dot(normalize(direction), -lightDir), 0.0);\n"
"    float sun = pow(sunDot, 1000.0); // sharpness of sun\n"
"    float glow = pow(sunDot, 10.0);  // soft glow around sun\n"
"\n"
"    vec3 sunColor = lightColor * vec3(1.0, 0.95, 0.8);\n"
"    baseSky += sunColor * sun * 2.0;  // bright sun center\n"
"    baseSky += sunColor * glow * 0.25; // soft glow\n"
"    \n"
"    // Hash for star randomness\n"
"    vec3 starDir = normalize(direction);\n"
"    ivec3 cell = ivec3(floor(starDir * 250.0)); // star cell grid\n"
"    uint h = hash(uvec3(cell), 92871u);\n"
"    float starRnd = float(h & 0xFFFFu) / 65535.0;\n"
"    \n"
"    if (starRnd > 0.999) { // rare stars\n"
"        baseSky += vec3(1.0) * (1.0 - dayAmount);\n"
"    }\n"
"\n"
"    return baseSky;\n"
"}\n"
"\n"
"bool isValid(vec3 pos) {\n"
"    return !any(greaterThanEqual(pos, VoxelCountPerChunk)) && !any(greaterThan(vec3(0.0), pos));\n"
"}\n"
"\n"
"bool rayAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tMin, out float tMax) {\n"
"    vec3 invDir = vec3(\n"
"        rayDir.x == 0.0 ? 1e32 : 1.0 / rayDir.x,\n"
"        rayDir.y == 0.0 ? 1e32 : 1.0 / rayDir.y,\n"
"        rayDir.z == 0.0 ? 1e32 : 1.0 / rayDir.z\n"
"    );\n"
"\n"
"    vec3 t0 = (boxMin - rayOrigin) * invDir;\n"
"    vec3 t1 = (boxMax - rayOrigin) * invDir;\n"
"\n"
"    vec3 tSmall = min(t0, t1);\n"
"    vec3 tBig   = max(t0, t1);\n"
"\n"
"    tMin = max(max(tSmall.x, tSmall.y), tSmall.z) + error_padding;\n"
"    tMax = min(min(tBig.x,   tBig.y), tBig.z) - error_padding;\n"
"\n"
"    return tMax > max(tMin, 0.0); // intersection exists if tMax >= tMin and in front of ray\n"
"}\n"
"\n"
"ivec3 getCubeNormal(vec3 pos, vec3 cubeCenter, vec3 cubehalfsize) {\n"
"	vec3 relativePos = pos - cubeCenter;\n"
"    vec3 absRelativePos = abs(relativePos / cubehalfsize);\n"
"\n"
"    float maxAxis = max(absRelativePos.x, max(absRelativePos.y, absRelativePos.z));\n"
"\n"
"    if (maxAxis == absRelativePos.x) {\n"
"        return ivec3(sign(relativePos.x), 0, 0);\n"
"    } else if (maxAxis == absRelativePos.y) {\n"
"        return ivec3(0, sign(relativePos.y), 0);\n"
"    } else {\n"
"        return ivec3(0, 0, sign(relativePos.z));\n"
"    }\n"
"}\n"
"\n"
"bool isEmpty(ivec3 subIndex, uint chunkIdx, vec3 chunkPos, out vec3 boxMin, out vec3 boxMax) {        \n"
"    int index = subIndex.x \n"
"              + subIndex.y * chunkSubDivision.x \n"
"              + subIndex.z * chunkSubDivision.x * chunkSubDivision.y;\n"
"\n"
"    boxMin = chunkPos + vec3(subIndex) * subDivisionSize;\n"
"    boxMax = boxMin + subDivisionSize;\n"
"\n"
"    uint subChunkVal = chunkEmpty[index + chunkIdx * subChunkStride];\n"
"    \n"
"    return subChunkVal == 1;\n"
"}\n"
"\n"
"HitPoint traverseChunk(uint chunkIdx, vec3 rayOrigin, vec3 rayDir, vec3 chunkPos, vec3 maxChunkPos, float Min, float Max) {\n"
"    rayOrigin += rayDir * Min;\n"
"\n"
"    // Clamp rayDir to avoid division by zero\n"
"    vec3 dirfrac = vec3(\n"
"        rayDir.x == 0.0 ? 1e32 : 1.0 / rayDir.x,\n"
"        rayDir.y == 0.0 ? 1e32 : 1.0 / rayDir.y,\n"
"        rayDir.z == 0.0 ? 1e32 : 1.0 / rayDir.z\n"
"    );\n"
"\n"
"    HitPoint hitpoint;\n"
"    hitpoint.color = vec4(0.0);\n"
"    ivec3 normal = ivec3(0.0);\n"
"    vec3 position = rayOrigin;\n"
"\n"
"    ivec3 currentIdx = ivec3(floor((rayOrigin - chunkPos) / voxelSize));\n"
"\n"
"    if (Min > 0.0) {\n"
"        normal = getCubeNormal(rayOrigin, chunkPos + chunkSize * 0.5, vec3(chunkSize * 0.5));\n"
"    }\n"
"\n"
"    vec3 tMax;\n"
"    vec3 delta;\n"
"    ivec3 step;\n"
"\n"
"    for (int i = 0; i < 3; i++) {\n"
"        if (rayDir[i] > 0.0) {\n"
"            step[i] = 1;\n"
"            delta[i] = voxelSize[i] * dirfrac[i];\n"
"            tMax[i] = ((chunkPos[i] + (currentIdx[i] + 1) * voxelSize[i]) - rayOrigin[i]) * dirfrac[i];\n"
"        } else {\n"
"            step[i] = -1;\n"
"            delta[i] = voxelSize[i] * -dirfrac[i];\n"
"            tMax[i] = ((chunkPos[i] + currentIdx[i] * voxelSize[i]) - rayOrigin[i]) * dirfrac[i];\n"
"        }\n"
"    }\n"
"\n"
"    uint baseIdx = chunkIdx * voxelOffsetByChunk;\n"
"\n"
"    ivec3 lastSubIndex = ivec3(-1);\n"
"    bool isSubChunkEmpty = false;\n"
"\n"
"    while (isValid(currentIdx)) {\n"
"        uint idx = getIndex(currentIdx) + baseIdx;\n"
"\n"
"        vec4 voxel = getVoxel(idx);\n"
"        if (voxel.a > 0.0) {\n"
"            hitpoint.position = position;\n"
"            hitpoint.normal = normal;\n"
"            hitpoint.color = voxel;\n"
"            return hitpoint;\n"
"        }\n"
"\n"
"        float hitT = min(tMax.x, min(tMax.y, tMax.z));\n"
"        if (hitT + Min > Max) break; // Exit if we exceed the maximum distance\n"
"        position = rayOrigin + rayDir * hitT;\n"
"\n"
"        if (tMax.x < tMax.y && tMax.x < tMax.z) {\n"
"            normal = ivec3(-step.x, 0, 0);\n"
"            currentIdx.x += step.x;\n"
"            tMax.x += delta.x;\n"
"        } else if (tMax.y < tMax.z) {\n"
"            normal = ivec3(0, -step.y, 0);\n"
"            currentIdx.y += step.y;\n"
"            tMax.y += delta.y;\n"
"        } else {\n"
"            normal = ivec3(0, 0, -step.z);\n"
"            currentIdx.z += step.z;\n"
"            tMax.z += delta.z;\n"
"        }\n"
"\n"
"        vec3 boxMin;\n"
"        vec3 boxMax;\n"
"        ivec3 subIndex = ivec3(floor((vec3(currentIdx) * voxelSize) / subDivisionSize));\n"
"        if (any(notEqual(subIndex, lastSubIndex))) {\n"
"            lastSubIndex = subIndex;\n"
"            isSubChunkEmpty = isEmpty(subIndex, chunkIdx, chunkPos, boxMin, boxMax);\n"
"        }\n"
"        if (isSubChunkEmpty) {\n"
"            vec3 t0 = (boxMin - rayOrigin) * dirfrac;\n"
"            vec3 t1 = (boxMax - rayOrigin) * dirfrac;\n"
"\n"
"            vec3 tBig  = max(t0, t1);\n"
"\n"
"            float edgeDist = min(min(tBig.x, tBig.y), tBig.z) + error_padding;\n"
"\n"
"            rayOrigin += rayDir * edgeDist;\n"
"            currentIdx = ivec3(floor((rayOrigin - chunkPos) / voxelSize));\n"
"\n"
"            for (int i = 0; i < 3; i++) {\n"
"                if (rayDir[i] > 0.0) {\n"
"                    tMax[i] = ((chunkPos[i] + (currentIdx[i] + 1) * voxelSize[i]) - rayOrigin[i]) * dirfrac[i];\n"
"                } else {\n"
"                    tMax[i] = ((chunkPos[i] + currentIdx[i] * voxelSize[i]) - rayOrigin[i]) * dirfrac[i];\n"
"                }\n"
"            }\n"
"\n"
"            float hitT = min(tMax.x, min(tMax.y, tMax.z));\n"
"            if (hitT + Min > Max) break; // Exit if we exceed the maximum distance\n"
"            position = rayOrigin - rayDir * hitT;\n"
"\n"
"            normal = -1 * getCubeNormal(rayOrigin, boxMin + subDivisionSize * 0.5, subDivisionSize * 0.5);\n"
"        }\n"
"    }\n"
"\n"
"    return hitpoint;\n"
"}\n"
"\n"
"bool inShadow(vec3 rayOrigin, vec3 lightDir, float minDist) {\n"
"    if (!u_EnableShadows) return false;\n"
"\n"
"    HitPoint minHitPoint;\n"
"    minHitPoint.color = vec4(0.0);\n"
"    rayOrigin += lightDir * voxelSize;\n"
"    for (uint i = 0; i < chunkNum; ++i) {\n"
"        vec3 boxMin = getChunk(i);\n"
"        vec3 boxMax = boxMin + chunkSize;\n"
"\n"
"        float tMin;\n"
"        float tMax;\n"
"\n"
"        if (rayAABB(rayOrigin, lightDir, boxMin, boxMax, tMin, tMax)) {\n"
"            if (tMin > minDist) continue; // Skip if the ray starts after the closest hit\n"
"\n"
"            HitPoint hitpoint = traverseChunk(i, rayOrigin, lightDir, boxMin, boxMax, max(0.0, tMin), tMax);\n"
"\n"
"            float dist2 = dot(hitpoint.position - rayOrigin, hitpoint.position - rayOrigin);\n"
"\n"
"            if (dist2 < minDist * minDist && hitpoint.color.a > 0.0) {\n"
"                minDist = sqrt(dist2);\n"
"                minHitPoint = hitpoint;\n"
"                return true; // Found a hit in shadow\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    return false;\n"
"}\n"
"\n"
"vec3 getDirLight(vec3 position, float distanceFromCam, vec3 rayDir, vec3 color, vec3 normal, DirLight light) {\n"
"    light.ambient *= light.color;\n"
"    light.diffuse *= light.color;\n"
"    light.specular *= light.color;\n"
"\n"
"    bool shadow = (distanceFromCam > u_ShadowDist) ? false : inShadow(position, -light.direction, u_ShadowFar);\n"
"\n"
"    vec3 lightDir = normalize(-light.direction);\n"
"\n"
"    vec3 ambient = light.ambient * color;\n"
"\n"
"    vec3 halfwayDir = normalize(lightDir - rayDir);\n"
"\n"
"    // diffuse shading\n"
"    float diff = max(dot(normal, lightDir), 0.0);\n"
"\n"
"    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n"
"\n"
"    // combine results\n"
"    vec3 diffuse = light.diffuse * diff * color * (shadow ? 0.1 : 1.0);\n"
"    vec3 specular = light.specular * spec * color * (shadow ? 0.1 : 1.0);\n"
"\n"
"    return ambient + diffuse + specular;\n"
"}\n"
"\n"
"// N = normal, V = view dir\n"
"vec3 getPointLights(vec3 N, vec3 V, vec3 hitPoint, vec3 color) {\n"
"    vec3 totalLight = vec3(0.0);\n"
"    int lightCount = 0;\n"
"    \n"
"    for (int i = 0; i < min(MAX_POINTLIGHTS, pointLightNum); ++i) {\n"
"        vec3 L = normalize(pointlights[i].position - hitPoint); // light direction\n"
"        float distance = length(pointlights[i].position - hitPoint);\n"
"    \n"
"        if (!inShadow(hitPoint, L, distance)) {\n"
"            vec3 H = normalize(L + V); // halfway vector for specular\n"
"    \n"
"            float attenuation = 1.0 / (distance * distance); // or linear if you prefer\n"
"            vec3 light = pointlights[i].color * attenuation;\n"
"    \n"
"            float diff = max(dot(N, L), 0.0);         // diffuse term\n"
"            float spec = pow(max(dot(N, H), 0.0), 32.0f); // specular term\n"
"    \n"
"            vec3 diffuse  = pointlights[i].diffuse * diff * light;        // kd: diffuse reflectivity (vec3)\n"
"            vec3 specular = pointlights[i].specular * spec * light;        // ks: specular reflectivity (vec3)\n"
"    \n"
"            totalLight += diffuse + specular;\n"
"            lightCount++;\n"
"        }\n"
"    }\n"
"    \n"
"    if (lightCount > 0)\n"
"        totalLight /= float(lightCount);\n"
"    \n"
"    // Final color = totalLight * surfaceColor\n"
"    return totalLight * color;\n"
"    \n"
"}\n"
"\n"
"vec3 getLight(vec3 position, float distanceFromCam, vec3 rayDir, vec3 color, vec3 normal) {\n"
"    if (u_MultipleLights == 1) return getDirLight(position, distanceFromCam, rayDir, color, normal, dirlight) + getPointLights(normal, rayDir, position, color);\n"
"    return getDirLight(position, distanceFromCam, rayDir, color, normal, dirlight);\n"
"}\n"
"\n"
"HitPoint getClosestHit(vec3 rayOrigin, vec3 rayDirection, out float minDist, float far) {\n"
"    minDist = far;\n"
"    HitPoint minHitPoint;\n"
"    for (uint i = 0; i < chunkNum; ++i) {\n"
"        vec3 boxMin = getChunk(i);\n"
"        vec3 boxMax = boxMin + chunkSize;\n"
"\n"
"        float tMin;\n"
"        float tMax;\n"
"\n"
"        if (rayAABB(rayOrigin, rayDirection, boxMin, boxMax, tMin, tMax)) {\n"
"            if (tMin > minDist) continue; // Skip if the ray starts after the closest hit\n"
"\n"
"            HitPoint hitpoint = traverseChunk(i, rayOrigin, rayDirection, boxMin, boxMax, max(0.0, tMin), tMax);\n"
"\n"
"            float dist2 = dot(hitpoint.position - rayOrigin, hitpoint.position - rayOrigin);\n"
"\n"
"            if (dist2 < minDist * minDist && hitpoint.color.a > 0.0) {\n"
"                minDist = sqrt(dist2);\n"
"                minHitPoint = hitpoint;\n"
"            }\n"
"        }\n"
"    }\n"
"    return minHitPoint;\n"
"}\n"
"\n"
"void main() {\n"
"    vec3 rayOrigin, rayDirection;\n"
"    getRay(rayOrigin, rayDirection);\n"
"\n"
"    float minDist;\n"
"    HitPoint minHitPoint = getClosestHit(rayOrigin, rayDirection, minDist, far);\n"
"\n"
"    bool bright = false;\n"
"\n"
"    if (minDist < far) {\n"
"        vec3 accumulatedColor = vec3(0.0);\n"
"        float accumulatedAlpha = 0.0;\n"
"        vec3 currentRayDir = rayDirection;\n"
"        vec3 currentRayOrigin = rayOrigin;\n"
"\n"
"        if (ViewingMode == 0) { // Render normally\n"
"            HitPoint hit = minHitPoint;\n"
"\n"
"            for (int i = 0; i < min(u_MaxReflectionNum, u_MaxTransparencyNum); ++i) {\n"
"                if (i > 0) {\n"
"                    hit = getClosestHit(currentRayOrigin, currentRayDir, minDist, far);\n"
"                    if (minDist >= far) {\n"
"                        // Hit nothing — use sky color\n"
"                        vec3 skyColor = sky(currentRayDir);\n"
"                        accumulatedColor = mix(accumulatedColor, skyColor, 1.0 - accumulatedAlpha);\n"
"                        accumulatedAlpha = 1.0;\n"
"                        break;\n"
"                    }\n"
"                }\n"
"\n"
"                float a = hit.color.a;\n"
"\n"
"                if (a == 0.0) {\n"
"                    // Skip empty space\n"
"                    currentRayOrigin += currentRayDir * (voxelSize * 2.0);\n"
"                    continue;\n"
"                }\n"
"                else if (a >= 1.0 || !u_EnableReflections || !u_EnableReflections) {\n"
"                    // Solid\n"
"                    vec3 light = getLight(hit.position, minDist, currentRayDir, hit.color.rgb, hit.normal);\n"
"                    accumulatedColor = mix(accumulatedColor, light, 1.0 - accumulatedAlpha);\n"
"                    accumulatedAlpha = 1.0;\n"
"                    break;\n"
"                }\n"
"                else if (a >= 0.9) {\n"
"                    // Emissive (direct color output)\n"
"                    accumulatedColor = mix(accumulatedColor, hit.color.rgb, 1.0 - accumulatedAlpha);\n"
"                    accumulatedAlpha = 1.0;\n"
"                    bright = true;\n"
"                    break;\n"
"                }\n"
"                else if (a > 0.5 && u_EnableReflections) {\n"
"                    // Reflective surface\n"
"                    float reflectivity = (a - 0.5) / 0.3; // remap 0.5–0.8 to 0.0–1.0\n"
"\n"
"                    vec3 reflectedDir = reflect(currentRayDir, hit.normal);\n"
"                    vec3 reflectedOrigin = hit.position + reflectedDir * voxelSize;\n"
"\n"
"                    HitPoint reflectedHit = getClosestHit(reflectedOrigin, reflectedDir, minDist, u_ReflectionFar);\n"
"\n"
"                    vec3 reflectedColor;\n"
"\n"
"                    if (minDist < u_ReflectionFar) {\n"
"                        // Properly compute lighting for the reflected surface\n"
"                        reflectedColor = getLight(reflectedHit.position, minDist, reflectedDir, reflectedHit.color.rgb, reflectedHit.normal);\n"
"                    } else {\n"
"                        // Fall back to sky if nothing is hit\n"
"                        reflectedColor = sky(reflectedDir);\n"
"                    }\n"
"\n"
"                    reflectedColor = min(hit.color.rgb * reflectedColor, vec3(1.0));\n"
"\n"
"                    // Blend reflection into the final color\n"
"                    accumulatedColor = mix(accumulatedColor, reflectedColor, reflectivity * (1.0 - accumulatedAlpha));\n"
"                    accumulatedAlpha += reflectivity * (1.0 - accumulatedAlpha);\n"
"\n"
"                    // Stop if we’re close to fully opaque\n"
"                    if (accumulatedAlpha > 0.99) break;\n"
"\n"
"                    // Continue the ray in the reflected direction for next loop (optional if you want multiple bounces)\n"
"                    currentRayOrigin = reflectedOrigin;\n"
"                    currentRayDir = reflectedDir;\n"
"                }\n"
"                else if (u_EnableTransparency) {\n"
"                    // Transparent\n"
"                    float alpha = clamp(a / 0.5, 0.0, 1.0);\n"
"                    vec3 light = getLight(hit.position, minDist, currentRayDir, hit.color.rgb, hit.normal);\n"
"\n"
"                    accumulatedColor = mix(accumulatedColor, light, alpha * (1.0 - accumulatedAlpha));\n"
"                    accumulatedAlpha += alpha * (1.0 - accumulatedAlpha);\n"
"\n"
"                    // Step through the object\n"
"                    currentRayOrigin = hit.position + currentRayDir * (voxelSize * 2.0);\n"
"\n"
"                    if (accumulatedAlpha > 0.99) break; // Early out if nearly opaque\n"
"                }\n"
"            }\n"
"\n"
"            fragColor = vec4(accumulatedColor, 1.0); // Final fully composited color\n"
"        }\n"
"\n"
"        else if (ViewingMode == 1) { // Raw Color\n"
"            fragColor = vec4(minHitPoint.color.rgb, 1.0);\n"
"        }\n"
"        else if (ViewingMode == 2) { // Normal Visualization\n"
"            fragColor = vec4(minHitPoint.normal.rgb, 1.0);\n"
"        }\n"
"        else if (ViewingMode == 3) { // Distance Visualization\n"
"            fragColor = vec4(vec3(minDist / far), 1.0);\n"
"        }\n"
"    }\n"
"    else {\n"
"        fragColor = vec4(sky(rayDirection), 1.0);\n"
"    }\n"
"\n"
"    float brightness = dot(fragColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n"
"    if (brightness > 0.7 || bright)\n"
"        BrightColor = vec4(fragColor.rgb, 1.0);\n"
"    else\n"
"        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"    gl_FragDepth = clamp(minDist / far, 0.0, 1.0 - error_padding);\n"
"}\n"
;
