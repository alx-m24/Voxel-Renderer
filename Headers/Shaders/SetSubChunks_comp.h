const char* SetSubChunks_comp =
"#version 430\n"
"\n"
"layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;\n"
"\n"
"uniform uint chunkIdx;\n"
"uniform float chunkSize;\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"uniform ivec3 chunkNum;\n"
"\n"
"uniform ivec3 chunkSubDivision;\n"
"\n"
"struct PointLight{\n"
"    vec3 position;\n"
"    vec3 color;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"};\n"
"\n"
"#define MAX_POINTLIGHTS 1\n"
"\n"
"uniform int pointLightNum;\n"
"uniform PointLight pointlights[MAX_POINTLIGHTS];\n"
"\n"
"layout(std430, binding = 0) buffer Chunks {\n"
"    uint chunks[];\n"
"};\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[];\n"
"};\n"
"\n"
"layout(std430, binding = 2) buffer ChunkEmpty {\n"
"    uint chunkEmpty[]; // 0 = not empty, 1 = empty, 2 = temporary not empty\n"
"};\n"
"\n"
"int unpackSigned10(uint v) {\n"
"    return (v & 0x200) != 0 ? int(v | 0xFFFFFC00) : int(v & 0x3FF);\n"
"}\n"
"\n"
"vec3 getChunk(uint idx) {\n"
"    uint packedChunk = chunks[idx];\n"
"    uint xBits = (packedChunk >> 20) & 0x3FF;\n"
"    uint yBits = (packedChunk >> 10) & 0x3FF;\n"
"    uint zBits =  packedChunk        & 0x3FF;\n"
"    return vec3(\n"
"        unpackSigned10(xBits),\n"
"        unpackSigned10(yBits),\n"
"        unpackSigned10(zBits)\n"
"    ) * chunkSize;\n"
"}\n"
"\n"
"int getIndex(ivec3 pos) {\n"
"    return pos.x + VoxelCountPerChunk.x * (pos.y + VoxelCountPerChunk.y * pos.z);\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"void setNotEmpty(vec3 position) {\n"
"    vec3 subDivisionSize = chunkSize / chunkSubDivision;\n"
"    \n"
"    ivec3 subIndex = ivec3(floor(vec3(position) / subDivisionSize));\n"
"    \n"
"    int index = subIndex.x\n"
"              + subIndex.y * chunkSubDivision.x \n"
"              + subIndex.z * chunkSubDivision.x * chunkSubDivision.y;\n"
"\n"
"    chunkEmpty[index + chunkIdx * chunkSubDivision.x * chunkSubDivision.y * chunkSubDivision.z] = 0;\n"
"}\n"
"\n"
"void main() {\n"
"    ivec3 localPos = ivec3(gl_GlobalInvocationID); // (0 to VoxelCountPerChunk - 1)\n"
"\n"
"    // Out of bounds check\n"
"    if (any(greaterThanEqual(localPos, VoxelCountPerChunk)) || any(greaterThan(vec3(0.0), localPos))) return;\n"
"\n"
"    vec3 voxelSpacing = chunkSize / vec3(VoxelCountPerChunk);\n"
"\n"
"    vec3 chunkOrigin = vec3(getChunk(chunkIdx));\n"
"    vec3 worldPos = chunkOrigin + vec3(localPos) * voxelSpacing;\n"
"\n"
"    uint index = getIndex(localPos) + (VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z * chunkIdx);\n"
"\n"
"//    for (int i = 0; i < min(MAX_POINTLIGHTS, pointLightNum); ++i) {\n"
"//        if (distance(pointlights[i].position, worldPos + voxelSpacing * 0.5) < voxelSpacing.x) {\n"
"//            voxels[index] = packRGBA(vec4(pointlights[i].color, 0.5));\n"
"//            break;\n"
"//        }\n"
"//    }\n"
"\n"
"    if (voxels[index] != 0) setNotEmpty(localPos * voxelSpacing);\n"
"}\n"
;
