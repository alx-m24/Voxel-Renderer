const char* Model_comp =
"#version 430\n"
"\n"
"layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;\n"
"\n"
"uniform usampler3D myTexture3D;  // note the \"u\"\n"
"uniform int zOffset; // animationFrame * modelSize.z;\n"
"\n"
"uniform ivec3 modelSize;\n"
"\n"
"uniform vec3 position;\n"
"uniform mat3 rotationalMatrix;\n"
"\n"
"uniform vec3 Lastposition;\n"
"uniform mat3 LastrotationalMatrix;\n"
"\n"
"uniform vec3 voxelSize;\n"
"uniform ivec3 chunkNum;\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[];\n"
"};\n"
"\n"
"struct Indexes{\n"
"    int chunkIdx;\n"
"    int voxelIdx;\n"
"};\n"
"\n"
"Indexes getIndex(vec3 worldPos) {\n"
"    ivec3 voxelGlobalIndex = ivec3(floor(worldPos / voxelSize));\n"
"    ivec3 chunkIndex = voxelGlobalIndex / VoxelCountPerChunk;\n"
"    ivec3 voxelIndex = voxelGlobalIndex % VoxelCountPerChunk;\n"
"\n"
"    // Out-of-bounds safety\n"
"    if (any(lessThan(chunkIndex, ivec3(0))) || any(greaterThanEqual(chunkIndex, chunkNum)))\n"
"        return Indexes(-1, -1);\n"
"\n"
"    int chunkFlatIndex = chunkIndex.x * (chunkNum.y * chunkNum.z) +\n"
"                     chunkIndex.y * chunkNum.z +\n"
"                     chunkIndex.z;\n"
"    int voxelFlatIndex = voxelIndex.z * (VoxelCountPerChunk.y * VoxelCountPerChunk.x) +\n"
"                         voxelIndex.y * VoxelCountPerChunk.x +\n"
"                         voxelIndex.x;\n"
"\n"
"    return Indexes(chunkFlatIndex, voxelFlatIndex + chunkFlatIndex * (VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z));\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"void Reset(ivec3 gid) {\n"
"    // Convert voxel grid coordinate to float position\n"
"    vec3 localPos = vec3(gid);  // before world translation\n"
"\n"
"    // Optional: Center model at origin before rotation\n"
"    vec3 center = vec3(modelSize) * 0.5;\n"
"    vec3 centeredPos = localPos - center;\n"
"\n"
"    // Apply rotation\n"
"    vec3 rotatedPos = LastrotationalMatrix * centeredPos;\n"
"\n"
"    // Move back and apply world position offset\n"
"    vec3 worldPos = rotatedPos + center + Lastposition;\n"
"    \n"
"    Indexes indexes = getIndex(worldPos);\n"
"    voxels[indexes.voxelIdx] = 0u;\n"
"}\n"
"\n"
"void main() {\n"
"    ivec3 gid = ivec3(gl_GlobalInvocationID);  // (x, y, z) -> (0, 0, 0) to vec3(modelSize)\n"
"\n"
"    Reset(gid);\n"
"\n"
"    ivec3 samplePos = ivec3(gid.xy, gid.z + zOffset);\n"
"\n"
"    // Sample voxel as uint32\n"
"    uint voxel = texelFetch(myTexture3D, samplePos, 0).r;\n"
"\n"
"    // Convert voxel grid coordinate to float position\n"
"    vec3 localPos = vec3(gid * voxelSize);  // before world translation\n"
"\n"
"    // Optional: Center model at origin before rotation\n"
"    vec3 center = vec3(modelSize) * 0.5;\n"
"    vec3 centeredPos = localPos - center;\n"
"\n"
"    // Apply rotation\n"
"    vec3 rotatedPos = rotationalMatrix * centeredPos;\n"
"\n"
"    // Move back and apply world position offset\n"
"    vec3 worldPos = rotatedPos + center + position;\n"
"    \n"
"    Indexes indexes = getIndex(worldPos);\n"
"    voxels[indexes.voxelIdx] = voxel;\n"
"}\n"
;
