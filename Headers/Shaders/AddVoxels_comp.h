const char* AddVoxels_comp =
"#version 430\n"
"\n"
"layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;\n"
"\n"
"uniform uint chunkIdx; \n"
"uniform float chunkSize;\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"uniform ivec3 chunkNum;\n"
"uniform vec3 cameraPos;\n"
"uniform vec3 origin;\n"
"uniform float radius;\n"
"\n"
"uniform ivec3 chunkSubDivision;\n"
"\n"
"layout(std430, binding = 0) buffer Chunks {\n"
"    uint chunks[];\n"
"};\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[];\n"
"};\n"
"\n"
"layout(std430, binding = 2) buffer ChunkEmpty {\n"
"    uint chunkEmpty[];\n"
"};\n"
"\n"
"int unpackSigned10(uint v) {\n"
"    return (v & 0x200) != 0 ? int(v | 0xFFFFFC00) : int(v & 0x3FF);\n"
"}\n"
"\n"
"vec3 getChunk(uint idx) {\n"
"    uint packedChunk = chunks[idx];\n"
"    uint xBits = (packedChunk >> 20) & 0x3FF;\n"
"    uint yBits = (packedChunk >> 10) & 0x3FF;\n"
"    uint zBits =  packedChunk        & 0x3FF;\n"
"    return vec3(\n"
"        unpackSigned10(xBits),\n"
"        unpackSigned10(yBits),\n"
"        unpackSigned10(zBits)\n"
"    ) * chunkSize;\n"
"}\n"
"\n"
"int getIndex(ivec3 pos) {\n"
"    return pos.x + VoxelCountPerChunk.x * (pos.y + VoxelCountPerChunk.y * pos.z);\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"void setNotEmpty(vec3 position) {\n"
"    vec3 subDivisionSize = chunkSize / chunkSubDivision;\n"
"    \n"
"    ivec3 subIndex = ivec3(floor(vec3(position) / subDivisionSize));\n"
"    \n"
"    int index = subIndex.x\n"
"              + subIndex.y * chunkSubDivision.x \n"
"              + subIndex.z * chunkSubDivision.x * chunkSubDivision.y;\n"
"\n"
"    chunkEmpty[index + chunkIdx * chunkSubDivision.x * chunkSubDivision.y * chunkSubDivision.z] = 0;\n"
"}\n"
"\n"
"void main() {\n"
"    ivec3 localPos = ivec3(gl_GlobalInvocationID); // (0 to VoxelCountPerChunk - 1)\n"
"\n"
"    // Out of bounds check\n"
"    if (any(greaterThanEqual(localPos, VoxelCountPerChunk)) || any(greaterThan(vec3(0.0), localPos))) return;\n"
"\n"
"    vec3 voxelSpacing = chunkSize / vec3(VoxelCountPerChunk);\n"
"    vec3 chunkOrigin = vec3(getChunk(chunkIdx));\n"
"    vec3 worldPos = chunkOrigin + vec3(localPos) * voxelSpacing;\n"
"\n"
"    vec3 A = cameraPos;\n"
"    vec3 B = origin;\n"
"    vec3 AB = B - A;\n"
"    vec3 AP = worldPos - A;\n"
"    \n"
"    float t = clamp(dot(AP, AB) / dot(AB, AB), 0.0, 1.0);\n"
"    vec3 closestPoint = A + t * AB;\n"
"    \n"
"    if (distance(worldPos, closestPoint) <= radius) {\n"
"        uint index = getIndex(localPos) + (VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z * chunkIdx);\n"
"        voxels[index] = packRGBA(vec4(1.0, 1.0, 1.0, 0.4));\n"
"    }\n"
"}\n"
;
