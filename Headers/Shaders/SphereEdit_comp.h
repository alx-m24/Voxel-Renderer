const char* SphereEdit_comp =
"#version 430\n"
"\n"
"layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;\n"
"\n"
"uniform uint chunkIdx; \n"
"uniform float chunkSize;\n"
"uniform ivec3 VoxelCountPerChunk;\n"
"uniform ivec3 chunkNum;\n"
"\n"
"uniform vec3 position;\n"
"uniform float radius;\n"
"\n"
"uniform vec4 color;\n"
"uniform bool randomizeColor;\n"
"\n"
"uniform bool delete;\n"
"\n"
"layout(std430, binding = 0) buffer Chunks {\n"
"    uint chunks[];\n"
"};\n"
"\n"
"layout(std430, binding = 1) buffer Voxels {\n"
"    uint voxels[];\n"
"};\n"
"\n"
"int unpackSigned10(uint v) {\n"
"    return (v & 0x200) != 0 ? int(v | 0xFFFFFC00) : int(v & 0x3FF);\n"
"}\n"
"\n"
"vec3 getChunk(uint idx) {\n"
"    uint packedChunk = chunks[idx];\n"
"    uint xBits = (packedChunk >> 20) & 0x3FF;\n"
"    uint yBits = (packedChunk >> 10) & 0x3FF;\n"
"    uint zBits =  packedChunk        & 0x3FF;\n"
"    return vec3(\n"
"        unpackSigned10(xBits),\n"
"        unpackSigned10(yBits),\n"
"        unpackSigned10(zBits)\n"
"    ) * chunkSize;\n"
"}\n"
"\n"
"int getIndex(ivec3 pos) {\n"
"    return pos.x + VoxelCountPerChunk.x * (pos.y + VoxelCountPerChunk.y * pos.z);\n"
"}\n"
"\n"
"uint packRGBA(vec4 color) {\n"
"    // Clamp and convert to 0–255 range\n"
"    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);\n"
"    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);\n"
"    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);\n"
"    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);\n"
"\n"
"    // Pack into a single uint: RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA\n"
"    return (r << 24) | (g << 16) | (b << 8) | a;\n"
"}\n"
"\n"
"float rand(vec3 co) {\n"
"    return fract(sin(dot(co, vec3(12.9898, 78.233, 37.719))) * 43758.5453);\n"
"}\n"
"\n"
"vec4 getColor(vec4 baseColor, vec3 seed, bool randomize) {\n"
"    if (!randomize) {\n"
"        return baseColor;\n"
"    }\n"
"\n"
"    // Generate small random offsets for each channel, e.g. [-0.05, 0.05]\n"
"    float Offset = (rand(seed + vec3(1.0, 0.0, 0.0)) - 0.5) * 0.1;\n"
"\n"
"    vec3 randomizedColor = clamp(baseColor.rgb + vec3(Offset), 0.0, 1.0);\n"
"    return vec4(randomizedColor, baseColor.a);\n"
"}\n"
"\n"
"void main() {\n"
"    ivec3 localPos = ivec3(gl_GlobalInvocationID); // (0 to VoxelCountPerChunk - 1)\n"
"\n"
"    // Out of bounds check\n"
"    if (any(greaterThanEqual(localPos, VoxelCountPerChunk)) || any(greaterThan(vec3(0.0), localPos))) return;\n"
"\n"
"    vec3 voxelSpacing = chunkSize / vec3(VoxelCountPerChunk);\n"
"    vec3 chunkOrigin = vec3(getChunk(chunkIdx));\n"
"    vec3 worldPos = chunkOrigin + vec3(localPos) * voxelSpacing;\n"
"    \n"
"    if (distance(worldPos, position) <= radius) {\n"
"        uint index = getIndex(localPos) + (VoxelCountPerChunk.x * VoxelCountPerChunk.y * VoxelCountPerChunk.z * chunkIdx);\n"
"        voxels[index] = (delete) ? packRGBA(vec4(0.0)) : packRGBA(getColor(color, worldPos, randomizeColor));\n"
"    }\n"
"}\n"
;
